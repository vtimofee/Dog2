using UnityEngine;namespace SelectedEffectOutline{	[RequireComponent(typeof(Camera))]	public class OutlineFilter : MonoBehaviour	{		[Header("Filter")]		public Color m_Color = Color.green;		public bool m_Obstacle = false;		[Range(0.2f, 2.2f)] public float m_BlurPixelOffset = 1.2f;		[Range(1f, 6f)] public float m_GlowIntensity = 3f;		public LayerMask m_LayerMask;		[Header("Material")]		public Shader m_SdrGlowFlatColor;		public Shader m_SdrDepthOnly;		public Material m_MatGlowHalo;		public Material m_MatGlowBlur;		Camera m_Camera;		Camera m_RTCam;		int m_ID_Offsets = 0;		int m_ID_GlowObjectTex = 0;		int m_ID_GlowColor = 0;		int m_ID_GlowIntensity = 0;		OutlineFilterObj[] m_OutlineFilterObjs;		void Start ()		{			m_OutlineFilterObjs = GameObject.FindObjectsOfType<OutlineFilterObj> ();			for (int i = 0; i < m_OutlineFilterObjs.Length; i++)				m_OutlineFilterObjs[i].Initialize ();			m_Camera = GetComponent<Camera> ();			// camera for post process outline			m_RTCam = new GameObject().AddComponent<Camera> ();			m_RTCam.name = "RTCam";			m_RTCam.transform.parent = m_Camera.gameObject.transform;			m_RTCam.enabled = false;			m_ID_Offsets = Shader.PropertyToID ("_Offsets");			m_ID_GlowObjectTex = Shader.PropertyToID ("_GlowObjectTex");			m_ID_GlowColor = Shader.PropertyToID ("_GlowColor");			m_ID_GlowIntensity = Shader.PropertyToID ("_GlowIntensity");		}		void DoBlurPass (RenderTexture input, RenderTexture output, bool vertical)		{			if (vertical)			{				m_MatGlowBlur.SetVector (m_ID_Offsets, new Vector4 (0f, m_BlurPixelOffset, 0f, 0f));				Graphics.Blit (input, output, m_MatGlowBlur);			}			else			{				m_MatGlowBlur.SetVector (m_ID_Offsets, new Vector4 (m_BlurPixelOffset, 0f, 0f, 0f));				Graphics.Blit (input, output, m_MatGlowBlur);			}		}		void OnRenderImage (RenderTexture src, RenderTexture dst)		{			Graphics.Blit (src, dst);   // prepare main back framebuffer			m_RTCam.CopyFrom (m_Camera);			m_RTCam.clearFlags = CameraClearFlags.Color;			m_RTCam.backgroundColor = Color.black;   // r as mask, should be black here			RenderTexture tempRT = RenderTexture.GetTemporary (src.width, src.height, 16, RenderTextureFormat.ARGB32);			m_RTCam.targetTexture = tempRT;			if (m_Obstacle)   // if obstacle enable, build depth buffer without glow object			{				m_RTCam.cullingMask = ~m_LayerMask;				m_RTCam.RenderWithShader (m_SdrDepthOnly, "");				m_RTCam.clearFlags = CameraClearFlags.Nothing;  // don't clear, keep depth buffer			}			m_RTCam.cullingMask = m_LayerMask;			m_RTCam.RenderWithShader (m_SdrGlowFlatColor, "");			// blur pass			int shrink = 1;  // shrink == 1 for best quality, try 2 or 4 for low quality but better performance			RenderTexture rt0 = RenderTexture.GetTemporary (Screen.width / shrink, Screen.height / shrink, 0, RenderTextureFormat.ARGB32);			RenderTexture rt1 = RenderTexture.GetTemporary (Screen.width / shrink, Screen.height / shrink, 0, RenderTextureFormat.ARGB32);			DoBlurPass (tempRT, rt0, true);			DoBlurPass (rt0, rt1, false);			// copy the temporary RT to the final image			m_MatGlowHalo.SetTexture (m_ID_GlowObjectTex, tempRT);			m_MatGlowHalo.SetColor (m_ID_GlowColor, m_Color);			m_MatGlowHalo.SetFloat (m_ID_GlowIntensity, m_GlowIntensity);			Graphics.Blit(rt1, dst, m_MatGlowHalo);			RenderTexture.ReleaseTemporary (tempRT);			RenderTexture.ReleaseTemporary (rt0);			RenderTexture.ReleaseTemporary (rt1);		}	}}